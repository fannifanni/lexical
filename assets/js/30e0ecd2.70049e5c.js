"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[8482],{876:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),h=r,g=p["".concat(s,".").concat(h)]||p[h]||d[h]||o;return n?a.createElement(g,i(i({ref:t},u),{},{components:n})):a.createElement(g,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},9660:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(7896),r=(n(2784),n(876));const o={sidebar_position:2},i="Getting Started with React",l={unversionedId:"getting-started/react",id:"getting-started/react",title:"Getting Started with React",description:"Video Tutorials",source:"@site/docs/getting-started/react.md",sourceDirName:"getting-started",slug:"/getting-started/react",permalink:"/lexical/docs/getting-started/react",draft:!1,editUrl:"https://github.com/fannifanni/lexical/tree/main/packages/lexical-website/docs/getting-started/react.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docs",previous:{title:"Quick Start (Vanilla JS)",permalink:"/lexical/docs/getting-started/quick-start"},next:{title:"Theming",permalink:"/lexical/docs/getting-started/theming"}},s={},c=[{value:"Video Tutorials",id:"video-tutorials",level:2},{value:"Code Sample",id:"code-sample",level:2}],u={toc:c};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"getting-started-with-react"},"Getting Started with React"),(0,r.kt)("h2",{id:"video-tutorials"},"Video Tutorials"),(0,r.kt)("p",null,"For a detailed walkthrough of setting up a basic editor with Lexical in React, check out these videos:"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=qIqxvk2qcmo"},"Getting Started with Lexical & React")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=pIBUFYd9zJY"},"Themes, Nodes, and Rich Text")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=5sRh_WXw0WI"},"Headings, Lists, Toolbar")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=abZNazybzvs"},"Creating Nodes and Plugins")),(0,r.kt)("h2",{id:"code-sample"},"Code Sample"),(0,r.kt)("p",null,"Install ",(0,r.kt)("inlineCode",{parentName:"p"},"lexical")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"@lexical/react"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npm install --save lexical @lexical/react\n")),(0,r.kt)("p",null,"Below is an example of a basic plain text editor using ",(0,r.kt)("inlineCode",{parentName:"p"},"lexical")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"@lexical/react")," (",(0,r.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/lexical-plain-text-example-g932e"},"try it yourself"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import {$getRoot, $getSelection} from 'lexical';\nimport {useEffect} from 'react';\n\nimport {LexicalComposer} from '@lexical/react/LexicalComposer';\nimport {PlainTextPlugin} from '@lexical/react/LexicalPlainTextPlugin';\nimport {ContentEditable} from '@lexical/react/LexicalContentEditable';\nimport {HistoryPlugin} from '@lexical/react/LexicalHistoryPlugin';\nimport {OnChangePlugin} from '@lexical/react/LexicalOnChangePlugin';\nimport {useLexicalComposerContext} from '@lexical/react/LexicalComposerContext';\nimport LexicalErrorBoundary from '@lexical/react/LexicalErrorBoundary';\n\nconst theme = {\n  // Theme styling goes here\n  ...\n}\n\n// Lexical React plugins are React components, which makes them\n// highly composable. Furthermore, you can lazy load plugins if\n// desired, so you don't pay the cost for plugins until you\n// actually use them.\nfunction MyCustomAutoFocusPlugin() {\n  const [editor] = useLexicalComposerContext();\n\n  useEffect(() => {\n    // Focus the editor when the effect fires!\n    editor.focus();\n  }, [editor]);\n\n  return null;\n}\n\n// Catch any errors that occur during Lexical updates and log them\n// or throw them as needed. If you don't throw them, Lexical will\n// try to recover gracefully without losing user data.\nfunction onError(error) {\n  console.error(error);\n}\n\nfunction Editor() {\n  const initialConfig = {\n    namespace: 'MyEditor',\n    theme,\n    onError,\n  };\n\n  return (\n    <LexicalComposer initialConfig={initialConfig}>\n      <PlainTextPlugin\n        contentEditable={<ContentEditable />}\n        placeholder={<div>Enter some text...</div>}\n        ErrorBoundary={LexicalErrorBoundary}\n      />\n      <HistoryPlugin />\n      <MyCustomAutoFocusPlugin />\n    </LexicalComposer>\n  );\n}\n")),(0,r.kt)("p",null,"Now that we have a simple editor in React, the next thing we might want to do is access the content of the editor to, for instance,\nsave it in a database. We can do this via the an ",(0,r.kt)("a",{parentName:"p",href:"https://lexical.dev/docs/concepts/listeners#registerupdatelistener"},"update listener"),", which will execute every time the editor state changes and provide us with the latest state. In React, we typically use the plugin system to set up listeners like this, since it provides us easy access to the LexicalEditor instance via a React Context. So, let's write our own plugin that notifies us when the editor updates."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"// When the editor changes, you can get notified via the\n// OnChangePlugin!\nfunction OnChangePlugin({ onChange }) {\n  // Access the editor through the LexicalComposerContext\n  const [editor] = useLexicalComposerContext();\n  // Wrap our listener in useEffect to handle the teardown and avoid stale references.\n  useEffect(() => {\n    // most listeners return a teardown function that can be called to clean them up.\n    return editor.registerUpdateListener((editorState) => {\n      // call onChange here to pass the latest state up to the parent.\n      onChange(editorState);\n    });\n  }, [editor, onChange]);\n\n}\n")),(0,r.kt)("p",null,"Now, we can implement this in our editor and save the EditorState in a React state variable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"function OnChangePlugin({ onChange }) {\n  const [editor] = useLexicalComposerContext();\n  useEffect(() => {\n    return editor.registerUpdateListener((editorState) => {\n      onChange(editorState);\n    });\n  }, [editor, onChange]);\n}\n\nfunction Editor() {\n  // ...\n\n  const [editorState, setEditorState] = useState();\n  function onChange(editorState) {\n    setEditorState(editorState);\n  }\n\n  return (\n    <LexicalComposer initialConfig={initialConfig}>\n      <PlainTextPlugin\n        contentEditable={<ContentEditable />}\n        placeholder={<div>Enter some text...</div>}\n        ErrorBoundary={LexicalErrorBoundary}\n      />\n      <HistoryPlugin />\n      <MyCustomAutoFocusPlugin />\n      <OnChangePlugin onChange={onChange}/>\n    </LexicalComposer>\n  );\n}\n\n")),(0,r.kt)("p",null,"Ok, so now we're saving the EditorState object in a React state variable, but we can't save a JavaScript object to our database - so how do we persist the state so we can load it later? We need to serialize it to a storage format. For this purpose (among others) Lexical provides several serialization APIs that convert EditorState to a string that can be sent over the network and saved to a database. Building on our previous example, we can do that this way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"function OnChangePlugin({ onChange }) {\n  const [editor] = useLexicalComposerContext();\n  useEffect(() => {\n    return editor.registerUpdateListener((editorState) => {\n      onChange(editorState);\n    });\n  }, [editor, onChange]);\n}\n\nfunction Editor() {\n  // ...\n\n  const [editorState, setEditorState] = useState();\n  function onChange(editorState) {\n    // Call toJSON on the EditorState object, which produces a serialization safe string\n    const editorStateJSON = editorState.toJSON();\n    // However, we still have a JavaScript object, so we need to convert it to an actual string with JSON.stringify\n    setEditorState(JSON.stringify(editorStateJSON));\n  }\n\n  return (\n    <LexicalComposer initialConfig={initialConfig}>\n      {/*...*/}\n      <OnChangePlugin onChange={onChange}/>\n    </LexicalComposer>\n  );\n\n")),(0,r.kt)("p",null,"From there, it's straightforward to wire up a submit button or some other UI trigger that will take the state from the React state variable and send it to a server for storage in a database."),(0,r.kt)("p",null,"One important thing to note: Lexical is generally meant to be uncontrolled, so avoid trying to pass the EditorState back into Editor.setEditorState or something along those lines."))}d.isMDXComponent=!0}}]);