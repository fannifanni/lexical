"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[2897],{876:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(n),h=r,g=u["".concat(l,".").concat(h)]||u[h]||p[h]||o;return n?a.createElement(g,i(i({ref:t},c),{},{components:n})):a.createElement(g,i({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7008:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(7896),r=(n(2784),n(876));const o={},i="Editor State",s={unversionedId:"concepts/editor-state",id:"concepts/editor-state",title:"Editor State",description:"Understanding the Editor State",source:"@site/docs/concepts/editor-state.md",sourceDirName:"concepts",slug:"/concepts/editor-state",permalink:"/lexical/docs/concepts/editor-state",draft:!1,editUrl:"https://github.com/fannifanni/lexical/tree/main/packages/lexical-website/docs/concepts/editor-state.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Supported Browsers",permalink:"/lexical/docs/getting-started/supported-browsers"},next:{title:"Nodes",permalink:"/lexical/docs/concepts/nodes"}},l={},d=[{value:"Understanding the Editor State",id:"understanding-the-editor-state",level:2},{value:"Updating state",id:"updating-state",level:2},{value:"State update listener",id:"state-update-listener",level:2},{value:"Cloning state",id:"cloning-state",level:3}],c={toc:d};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"editor-state"},"Editor State"),(0,r.kt)("h2",{id:"understanding-the-editor-state"},"Understanding the Editor State"),(0,r.kt)("p",null,"With Lexical, the source of truth is not the DOM, but rather an underlying state model\nthat Lexical maintains and associates with an editor instance. You can get the latest\neditor state from an editor by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"editor.getEditorState()"),"."),(0,r.kt)("p",null,"Editor states have two phases:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'During an update they can be thought of as "mutable". See "Updating state" below to\nmutate an editor state.'),(0,r.kt)("li",{parentName:"ul"},'After an update, the editor state is then locked and deemed immutable from there on. This\neditor state can therefore be thought of as a "snapshot".')),(0,r.kt)("p",null,"Editor states contain two core things:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The editor node tree (starting from the root node)."),(0,r.kt)("li",{parentName:"ul"},"The editor selection (which can be null).")),(0,r.kt)("p",null,"Editor states are serializable to JSON, and the editor instance provides a useful method\nto deserialize stringified editor states."),(0,r.kt)("p",null,"Here's an example of how you can initialize editor with some state and then persist it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Get editor initial state (e.g. loaded from backend)\nconst loadContent = async () => {\n  // \'empty\' editor\n  const value = \'{"root":{"children":[{"children":[],"direction":null,"format":"","indent":0,"type":"paragraph","version":1}],"direction":null,"format":"","indent":0,"type":"root","version":1}}\';\n\n  return value;\n}\n\nconst initialEditorState = await loadContent();\nconst editor = createEditor(...);\nregisterRichText(editor, initialEditorState);\n\n...\n\n// Handler to store content (e.g. when user submits a form)\nconst onSubmit = () => {\n  await saveContent(JSON.stringify(editor.getEditorState()));\n}\n')),(0,r.kt)("p",null,"For React it could be something following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'const initialEditorState = await loadContent();\nconst editorStateRef = useRef();\n\n<LexicalComposer initialConfig={{\n  editorState: initialEditorState\n}}>\n  <LexicalRichTextPlugin />\n  <LexicalOnChangePlugin onChange={editorState => editorStateRef.current = editorState} />\n  <Button label="Save" onPress={() => {\n    if (editorStateRef.current) {\n      saveContent(JSON.stringify(editorStateRef.current))\n    }\n  }} />\n</LexicalComposer>\n')),(0,r.kt)("p",null,"Note that Lexical uses ",(0,r.kt)("inlineCode",{parentName:"p"},"initialConfig.editorState")," only once (when it's being initialized) and passing different value later\nwon't be reflected in editor. See \"Update state\" below for proper ways of updating editor state."),(0,r.kt)("h2",{id:"updating-state"},"Updating state"),(0,r.kt)("p",null,"The most common way to update the editor is to use ",(0,r.kt)("inlineCode",{parentName:"p"},"editor.update()"),". Calling this function\nrequires a function to be passed in that will provide access to mutate the underlying\neditor state. When starting a fresh update, the current editor state is cloned and\nused as the starting point. From a technical perspective, this means that Lexical leverages a technique\ncalled double-buffering during updates. There's an editor state to represent what is current on\nthe screen, and another work-in-progress editor state that represents future changes."),(0,r.kt)("p",null,"Creating an update is typically an async process that allows Lexical to batch multiple updates together in\na single update \u2013 improving performance. When Lexical is ready to commit the update to\nthe DOM, the underlying mutations and changes in the update will form a new immutable\neditor state. Calling ",(0,r.kt)("inlineCode",{parentName:"p"},"editor.getEditorState()")," will then return the latest editor state\nbased on the changes from the update."),(0,r.kt)("p",null,"Here's an example of how you can update an editor instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {$getRoot, $getSelection} from 'lexical';\nimport {$createParagraphNode} from 'lexical';\n\n// Inside the `editor.update` you can use special $ prefixed helper functions.\n// These functions cannot be used outside the closure, and will error if you try.\n// (If you're familiar with React, you can imagine these to be a bit like using a hook\n// outside of a React function component).\neditor.update(() => {\n  // Get the RootNode from the EditorState\n  const root = $getRoot();\n\n  // Get the selection from the EditorState\n  const selection = $getSelection();\n\n  // Create a new ParagraphNode\n  const paragraphNode = $createParagraphNode();\n\n  // Create a new TextNode\n  const textNode = $createTextNode('Hello world');\n\n  // Append the text node to the paragraph\n  paragraphNode.append(textNode);\n\n  // Finally, append the paragraph to the root\n  root.append(paragraphNode);\n});\n")),(0,r.kt)("p",null,"Another way to set state is ",(0,r.kt)("inlineCode",{parentName:"p"},"setEditorState")," method, which replaces current state with the one passed as an argument."),(0,r.kt)("p",null,"Here's an example of how you can set editor state from a stringified JSON:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const editorState = editor.parseEditorState(editorStateJSONString);\neditor.setEditorState(editorState);\n")),(0,r.kt)("h2",{id:"state-update-listener"},"State update listener"),(0,r.kt)("p",null,"If you want to know when the editor updates so you can react to the changes, you can add an update\nlistener to the editor, as shown below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"editor.registerUpdateListener(({editorState}) => {\n  // The latest EditorState can be found as `editorState`.\n  // To read the contents of the EditorState, use the following API:\n\n  editorState.read(() => {\n    // Just like editor.update(), .read() expects a closure where you can use\n    // the $ prefixed helper functions.\n  });\n});\n")),(0,r.kt)("h3",{id:"cloning-state"},"Cloning state"),(0,r.kt)("p",null,"Lexical state can be cloned, optionally with custom selection. One of the scenarios where you'd want to do it\nis setting editor's state but not forcing any selection:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// Passing `null` as a selection value to prevent focusing the editor\neditor.setEditorState(editorState.clone(null));\n")))}p.isMDXComponent=!0}}]);