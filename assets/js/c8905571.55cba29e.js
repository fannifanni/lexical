"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[4913],{876:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>u});var o=t(2784);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function d(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),s=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=s(e.components);return o.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=d(e,["components","mdxType","originalType","parentName"]),m=s(t),u=a,N=m["".concat(l,".").concat(u)]||m[u]||c[u]||r;return t?o.createElement(N,i(i({ref:n},p),{},{components:t})):o.createElement(N,i({ref:n},p))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=m;var d={};for(var l in n)hasOwnProperty.call(n,l)&&(d[l]=n[l]);d.originalType=e,d.mdxType="string"==typeof e?e:a,i[1]=d;for(var s=2;s<r;s++)i[s]=t[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},7901:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>d,toc:()=>s});var o=t(7896),a=(t(2784),t(876));const r={},i="Nodes",d={unversionedId:"concepts/nodes",id:"concepts/nodes",title:"Nodes",description:"Base Nodes",source:"@site/docs/concepts/nodes.md",sourceDirName:"concepts",slug:"/concepts/nodes",permalink:"/lexical/docs/concepts/nodes",draft:!1,editUrl:"https://github.com/fannifanni/lexical/tree/main/packages/lexical-website/docs/concepts/nodes.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Editor State",permalink:"/lexical/docs/concepts/editor-state"},next:{title:"Node Overrides",permalink:"/lexical/docs/concepts/node-replacement"}},l={},s=[{value:"Base Nodes",id:"base-nodes",level:2},{value:"<code>RootNode</code>",id:"rootnode",level:3},{value:"<code>LineBreakNode</code>",id:"linebreaknode",level:3},{value:"<code>ElementNode</code>",id:"elementnode",level:3},{value:"<code>TextNode</code>",id:"textnode",level:3},{value:"<code>DecoratorNode</code>",id:"decoratornode",level:3},{value:"Node Properties",id:"node-properties",level:2},{value:"Creating custom nodes",id:"creating-custom-nodes",level:2},{value:"Extending <code>ElementNode</code>",id:"extending-elementnode",level:3},{value:"Extending <code>TextNode</code>",id:"extending-textnode",level:3},{value:"Extending <code>DecoratorNode</code>",id:"extending-decoratornode",level:3}],p={toc:s};function c(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"nodes"},"Nodes"),(0,a.kt)("h2",{id:"base-nodes"},"Base Nodes"),(0,a.kt)("p",null,"Nodes are a core concept in Lexical. Not only do they form the visual editor view, as part of the ",(0,a.kt)("inlineCode",{parentName:"p"},"EditorState"),", but they also represent the\nunderlying data model for what is stored in the editor at any given time. Lexical has a single core based node, called ",(0,a.kt)("inlineCode",{parentName:"p"},"LexicalNode")," that\nis extended internally to create Lexical's five base nodes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"RootNode")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"LineBreakNode")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ElementNode")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TextNode")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"DecoratorNode"))),(0,a.kt)("p",null,"Of these nodes, three of them are exposed from the ",(0,a.kt)("inlineCode",{parentName:"p"},"lexical")," package, making them ideal to be extended:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"ElementNode")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TextNode")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"DecoratorNode"))),(0,a.kt)("h3",{id:"rootnode"},(0,a.kt)("a",{parentName:"h3",href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalRootNode.ts"},(0,a.kt)("inlineCode",{parentName:"a"},"RootNode"))),(0,a.kt)("p",null,"There is only ever a single ",(0,a.kt)("inlineCode",{parentName:"p"},"RootNode")," in an ",(0,a.kt)("inlineCode",{parentName:"p"},"EditorState")," and it is always at the top and it represents the\n",(0,a.kt)("inlineCode",{parentName:"p"},"contenteditable")," itself. This means that the ",(0,a.kt)("inlineCode",{parentName:"p"},"RootNode")," does not have a parent or siblings."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"To get the text content of the entire editor, you should use ",(0,a.kt)("inlineCode",{parentName:"li"},"rootNode.getTextContent()"),"."),(0,a.kt)("li",{parentName:"ul"},"To avoid selection issues, Lexical forbids insertion of text nodes directly into a ",(0,a.kt)("inlineCode",{parentName:"li"},"RootNode"),".")),(0,a.kt)("h3",{id:"linebreaknode"},(0,a.kt)("a",{parentName:"h3",href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalLineBreakNode.ts"},(0,a.kt)("inlineCode",{parentName:"a"},"LineBreakNode"))),(0,a.kt)("p",null,"You should never have ",(0,a.kt)("inlineCode",{parentName:"p"},"'\\n'")," in your text nodes, instead you should use the ",(0,a.kt)("inlineCode",{parentName:"p"},"LineBreakNode")," which represents\n",(0,a.kt)("inlineCode",{parentName:"p"},"'\\n'"),", and more importantly, can work consistently between browsers and operating systems."),(0,a.kt)("h3",{id:"elementnode"},(0,a.kt)("a",{parentName:"h3",href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalElementNode.ts"},(0,a.kt)("inlineCode",{parentName:"a"},"ElementNode"))),(0,a.kt)("p",null,"Used as parent for other nodes, can be block level (",(0,a.kt)("inlineCode",{parentName:"p"},"ParagraphNode"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"HeadingNode"),") and inline (",(0,a.kt)("inlineCode",{parentName:"p"},"LinkNode"),").\nHas various methods which define its behaviour that can be overridden during extension (",(0,a.kt)("inlineCode",{parentName:"p"},"isInline"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"canBeEmpty"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"canInsertTextBefore")," and more)"),(0,a.kt)("h3",{id:"textnode"},(0,a.kt)("a",{parentName:"h3",href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalTextNode.ts"},(0,a.kt)("inlineCode",{parentName:"a"},"TextNode"))),(0,a.kt)("p",null,"Leaf type of node that contains text. It also includes few text-specific properties:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"format")," any combination of ",(0,a.kt)("inlineCode",{parentName:"li"},"bold"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"italic"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"underline"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"strikethrough"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"code"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"subscript")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"superscript")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"mode"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"token")," - acts as immutable node, can't change its content and is deleted all at once"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"segmented")," - its content deleted by segments (one word at a time), it is editable although node becomes non-segmented once its content is updated"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"style")," can be used to apply inline css styles to text")),(0,a.kt)("h3",{id:"decoratornode"},(0,a.kt)("a",{parentName:"h3",href:"https://github.com/facebook/lexical/blob/main/packages/lexical/src/nodes/LexicalDecoratorNode.ts"},(0,a.kt)("inlineCode",{parentName:"a"},"DecoratorNode"))),(0,a.kt)("p",null,"Wrapper node to insert arbitrary view (component) inside the editor. Decorator node rendering is framework-agnostic and\ncan output components from React, vanilla js or other frameworks."),(0,a.kt)("h2",{id:"node-properties"},"Node Properties"),(0,a.kt)("p",null,"Lexical nodes can have properties. It's important that these properties are JSON serializable too, so you should never\nbe assigning a property to a node that is a function, Symbol, Map, Set, or any other object that has a different prototype\nthan the built-ins. ",(0,a.kt)("inlineCode",{parentName:"p"},"null"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"number"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"boolean"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"{}")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"[]")," are all types of property that can be\nassigned to node."),(0,a.kt)("p",null,"By convention, we prefix properties with ",(0,a.kt)("inlineCode",{parentName:"p"},"__")," (double underscore) so that it makes it clear that these properties are private\nand their access should be avoided directly. We opted for ",(0,a.kt)("inlineCode",{parentName:"p"},"__")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"_")," because of the fact that some build tooling\nmangles and minifies single ",(0,a.kt)("inlineCode",{parentName:"p"},"_")," prefixed properties to improve code size. However, this breaks down if you're exposing a node\nto be extended outside of your build."),(0,a.kt)("p",null,"If you are adding a property that you expect to be modifiable or accessible, then you should always create a set of ",(0,a.kt)("inlineCode",{parentName:"p"},"get*()"),"\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"set*()")," methods on your node for this property. Inside these methods, you'll need to invoke some very important methods\nthat ensure consistency with Lexical's internal immutable system. These methods are ",(0,a.kt)("inlineCode",{parentName:"p"},"getWritable()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"getLatest()"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import type {NodeKey} from 'lexical';\n\nclass MyCustomNode extends SomeOtherNode {\n  __foo: string;\n\n  constructor(foo: string, key?: NodeKey) {\n    super(key);\n    this.__foo = foo;\n  }\n\n  setFoo(foo: string) {\n    // getWritable() creates a clone of the node\n    // if needed, to ensure we don't try and mutate\n    // a stale version of this node.\n    const self = this.getWritable();\n    self.__foo = foo;\n  }\n\n  getFoo(): string {\n    // getLatest() ensures we are getting the most\n    // up-to-date value from the EditorState.\n    const self = this.getLatest();\n    return self.__foo;\n  }\n}\n")),(0,a.kt)("p",null,"Lastly, all nodes should have both a ",(0,a.kt)("inlineCode",{parentName:"p"},"static getType()")," method and a ",(0,a.kt)("inlineCode",{parentName:"p"},"static clone()")," method.\nLexical uses the type to be able to reconstruct a node back with its associated class prototype\nduring deserialization (important for copy + paste!). Lexical uses cloning to ensure consistency\nbetween creation of new ",(0,a.kt)("inlineCode",{parentName:"p"},"EditorState")," snapshots."),(0,a.kt)("p",null,"Expanding on the example above with these methods:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"class MyCustomNode extends SomeOtherNode {\n  __foo: string;\n\n  static getType(): string {\n    return 'custom-node';\n  }\n\n  static clone(node: MyCustomNode): MyCustomNode {\n    return new MyCustomNode(node.__foo, node.__key);\n  }\n\n  constructor(foo: string, key?: NodeKey) {\n    super(key);\n    this.__foo = foo;\n  }\n\n  setFoo(foo: string) {\n    // getWritable() creates a clone of the node\n    // if needed, to ensure we don't try and mutate\n    // a stale version of this node.\n    const self = this.getWritable();\n    self.__foo = foo;\n  }\n\n  getFoo(): string {\n    // getLatest() ensures we are getting the most\n    // up-to-date value from the EditorState.\n    const self = this.getLatest();\n    return self.__foo;\n  }\n}\n")),(0,a.kt)("h2",{id:"creating-custom-nodes"},"Creating custom nodes"),(0,a.kt)("p",null,"As mentioned above, Lexical exposes three base nodes that can be extended."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Did you know? Nodes such as ",(0,a.kt)("inlineCode",{parentName:"p"},"ElementNode")," are already extended in the core by Lexical, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"ParagraphNode")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"RootNode"),"!")),(0,a.kt)("h3",{id:"extending-elementnode"},"Extending ",(0,a.kt)("inlineCode",{parentName:"h3"},"ElementNode")),(0,a.kt)("p",null,"Below is an example of how you might extend ",(0,a.kt)("inlineCode",{parentName:"p"},"ElementNode"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import {ElementNode} from 'lexical';\n\nexport class CustomParagraph extends ElementNode {\n  static getType(): string {\n    return 'custom-paragraph';\n  }\n\n  static clone(node: ParagraphNode): ParagraphNode {\n    return new CustomParagraph(node.__key);\n  }\n\n  createDOM(): HTMLElement {\n    // Define the DOM element here\n    const dom = document.createElement('p');\n    return dom;\n  }\n\n  updateDOM(prevNode: CustomParagraph, dom: HTMLElement): boolean {\n    // Returning false tells Lexical that this node does not need its\n    // DOM element replacing with a new copy from createDOM.\n    return false;\n  }\n}\n")),(0,a.kt)("p",null,"It's also good etiquette to provide some ",(0,a.kt)("inlineCode",{parentName:"p"},"$")," prefixed utility functions for\nyour custom ",(0,a.kt)("inlineCode",{parentName:"p"},"ElementNode")," so that others can easily consume and validate nodes\nare that of your custom node. Here's how you might do this for the above example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"export function $createCustomParagraphNode(): ParagraphNode {\n  return new CustomParagraph();\n}\n\nexport function $isCustomParagraphNode(node: LexicalNode | null | undefined): node is CustomParagraph  {\n  return node instanceof CustomParagraph;\n}\n")),(0,a.kt)("h3",{id:"extending-textnode"},"Extending ",(0,a.kt)("inlineCode",{parentName:"h3"},"TextNode")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"export class ColoredNode extends TextNode {\n  __color: string;\n\n  constructor(text: string, color: string, key?: NodeKey): void {\n    super(text, key);\n    this.__color = color;\n  }\n\n  static getType(): string {\n    return 'colored';\n  }\n\n  static clone(node: ColoredNode): ColoredNode {\n    return new ColoredNode(node.__text, node.__color, node.__key);\n  }\n\n  createDOM(config: EditorConfig): HTMLElement {\n    const element = super.createDOM(config);\n    element.style.color = this.__color;\n    return element;\n  }\n\n  updateDOM(\n    prevNode: ColoredNode,\n    dom: HTMLElement,\n    config: EditorConfig,\n  ): boolean {\n    const isUpdated = super.updateDOM(prevNode, dom, config);\n    if (prevNode.__color !== this.__color) {\n      dom.style.color = this.__color;\n    }\n    return isUpdated;\n  }\n}\n\nexport function $createColoredNode(text: string, color: string): ColoredNode {\n  return new ColoredNode(text, color);\n}\n\nexport function $isColoredNode(node: LexicalNode | null | undefined): node is ColoredNode {\n  return node instanceof ColoredNode;\n}\n")),(0,a.kt)("h3",{id:"extending-decoratornode"},"Extending ",(0,a.kt)("inlineCode",{parentName:"h3"},"DecoratorNode")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export class VideoNode extends DecoratorNode<ReactNode> {\n  __id: string;\n\n  static getType(): string {\n    return 'video';\n  }\n\n  static clone(node: VideoNode): VideoNode {\n    return new VideoNode(node.__id, node.__key);\n  }\n\n  constructor(id: string, key?: NodeKey) {\n    super(key);\n    this.__id = id;\n  }\n\n  createDOM(): HTMLElement {\n    return document.createElement('div');\n  }\n\n  updateDOM(): false {\n    return false;\n  }\n\n  decorate(): ReactNode {\n    return <VideoPlayer videoID={this.__id} />;\n  }\n}\n\nexport function $createVideoNode(id: string): VideoNode {\n  return new VideoNode(id);\n}\n\nexport function $isVideoNode(node: LexicalNode | null | undefined): node is VideoNode {\n  return node instanceof VideoNode;\n}\n")))}c.isMDXComponent=!0}}]);