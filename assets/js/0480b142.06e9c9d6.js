"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[836],{876:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(2784);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,h=u["".concat(s,".").concat(m)]||u[m]||p[m]||i;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2561:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=n(7896),o=(n(2784),n(876));const i={sidebar_position:7},r="FAQ",l={unversionedId:"faq",id:"faq",title:"FAQ",description:"Why does Lexical use the $ prefix in the name of many of the functions?",source:"@site/docs/faq.md",sourceDirName:".",slug:"/faq",permalink:"/lexical/docs/faq",draft:!1,editUrl:"https://github.com/fannifanni/lexical/tree/main/packages/lexical-website/docs/faq.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"docs",previous:{title:"React",permalink:"/lexical/docs/collaboration/react"}},s={},c=[{value:"Why does Lexical use the <code>$</code> prefix in the name of many of the functions?",id:"why-does-lexical-use-the--prefix-in-the-name-of-many-of-the-functions",level:2},{value:"How do I listen for user text insertions?",id:"how-do-i-listen-for-user-text-insertions",level:2},{value:"How do I clear the contents of the editor?",id:"how-do-i-clear-the-contents-of-the-editor",level:2},{value:"How do I listen to specific key down events?",id:"how-do-i-listen-to-specific-key-down-events",level:2}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"faq"},"FAQ"),(0,o.kt)("h2",{id:"why-does-lexical-use-the--prefix-in-the-name-of-many-of-the-functions"},"Why does Lexical use the ",(0,o.kt)("inlineCode",{parentName:"h2"},"$")," prefix in the name of many of the functions?"),(0,o.kt)("p",null,"Originally, Lexical didn't have ",(0,o.kt)("inlineCode",{parentName:"p"},"$")," functions, instead these functions were provided to you through callback params:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// Mid 2020 API\neditor.update((viewState) => {\n  const getRoot = viewState.getRoot();\n  ..\n});\neditor.addTextTransform((viewState) => {\n  const getRoot = viewState.getRoot();\n  ..\n});\n")),(0,o.kt)("p",null,"Internally, this approach raised some negative feedback:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"viewState")," terminology was confusing. It wasn't really a ",(0,o.kt)("inlineCode",{parentName:"li"},"viewState"),", more like a toolkit to manipulate the ",(0,o.kt)("inlineCode",{parentName:"li"},"EditorState")),(0,o.kt)("li",{parentName:"ul"},"For complex updates and transforms devs had to carry params around on many layers")),(0,o.kt)("p",null,'This is when we decided to leverage the "lexical" scope instead to perform ',(0,o.kt)("inlineCode",{parentName:"p"},"EditorState")," manipulation, and the ",(0,o.kt)("inlineCode",{parentName:"p"},"$")," represents just that."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"editor.update(() => ...);\neditor.registerNodeTransform(FooNode, () => ...);\neditor.getEditorState().read(...);\n")),(0,o.kt)("p",null,"If you've used React Hooks before, you can think of ",(0,o.kt)("inlineCode",{parentName:"p"},"$")," functions as being something that follows a similar pattern. These are functions that show their intent as to where they can or cannot be used. This makes it possible for a developer to create their own functions that give the same signal, by simply prefixing the function with the dollar."),(0,o.kt)("p",null,"Internally, we've found this scales really well and developers get to grips with it in almost no time at all."),(0,o.kt)("h2",{id:"how-do-i-listen-for-user-text-insertions"},"How do I listen for user text insertions?"),(0,o.kt)("p",null,"Listening to text insertion events is problematic with content editables in general. It's a common source of bugs due to how\ndifferent browsers and third-party extensions interact with the DOM. Whilst it's possible to use DOM events like ",(0,o.kt)("inlineCode",{parentName:"p"},"input")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"beforeinput")," to gauge some of the possible cases where a user has inserted text, these are hardly reliable and also don't\ntake into account edge-cases. Instead, Lexical prefers to consider any change as a possible user input, and as such doesn't\nmake a distinction between the cases. This is important for tools like spellcheck, browser extensions, IME, speech-to-text,\nscreen readers and other external tools that often don't reliably trigger a reliable event sequence (some don't even trigger\nany events at all!)."),(0,o.kt)("p",null,"For those wanting to react to a text change and possibly block/alter the intent, the recommended approach is to use a node\ntransform. This also plays nicely with other sub-systems at play that might also be looking to do the same thing as you."),(0,o.kt)("p",null,"For those who just want to know of the changes, this can be achieved using a text content listener or an editor update listener."),(0,o.kt)("h2",{id:"how-do-i-clear-the-contents-of-the-editor"},"How do I clear the contents of the editor?"),(0,o.kt)("p",null,"You can go this by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"clear()")," on the RootNode in an update callback:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"editor.update(() => {\n  $getRoot().clear();\n})\n")),(0,o.kt)("h2",{id:"how-do-i-listen-to-specific-key-down-events"},"How do I listen to specific key down events?"),(0,o.kt)("p",null,"You can leverage Lexical's command listening system. Lexical provides specific commands for many common keyboard operations, such as:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"KEY_ARROW_LEFT_COMMAND")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"KEY_ARROW_RIGHT_COMMAND")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"KEY_ARROW_UP_COMMAND")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"KEY_ARROW_DOWN_COMMAND")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"KEY_SPACE_COMMAND")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"KEY_ENTER_COMMAND")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"KEY_BACKSPACE_COMMAND")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"KEY_DELETE_COMMAND")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"KEY_TAB_COMMAND")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"KEY_ESCAPE_COMMAND"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import {KEY_ENTER_COMMAND, COMMAND_PRIORITY_LOW} from 'lexical';\n\neditor.registerCommand(KEY_ENTER_COMMAND, (event: KeyboardEvent) => {\n  // Handle enter key presses here\n  return false;\n}, COMMAND_PRIORITY_LOW)\n")),(0,o.kt)("p",null,"You can use the generic ",(0,o.kt)("inlineCode",{parentName:"p"},"KEY_DOWN_COMMAND")," command to listen\nto all keydown events. Do note, that returning ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," in your listener will prevent any\nother key based commands from firing, so in most cases you'll want to return ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," from\nthe command listener."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import {KEY_DOWN_COMMAND, COMMAND_PRIORITY_LOW} from 'lexical';\n\neditor.registerCommand(KEY_DOWN_COMMAND, (event: KeyboardEvent) => {\n  // Handle event here\n  return false;\n}, COMMAND_PRIORITY_LOW)\n")))}p.isMDXComponent=!0}}]);