"use strict";(self.webpackChunk_lexical_website=self.webpackChunk_lexical_website||[]).push([[4677],{876:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>u});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),c=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=c(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=c(n),u=r,f=d["".concat(p,".").concat(u)]||d[u]||m[u]||o;return n?a.createElement(f,i(i({ref:t},s),{},{components:n})):a.createElement(f,i({ref:t},s))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7619:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(7896),r=(n(2784),n(876));const o={title:"",sidebar_position:4,sidebar_label:"@lexical/selection"},i=void 0,l={unversionedId:"packages/lexical-selection",id:"packages/lexical-selection",title:"",description:"{@import ../../../lexical-selection/README.md}",source:"@site/docs/packages/lexical-selection.md",sourceDirName:"packages",slug:"/packages/lexical-selection",permalink:"/lexical/docs/packages/lexical-selection",draft:!1,editUrl:"https://github.com/fannifanni/lexical/tree/main/packages/lexical-website/docs/packages/lexical-selection.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"",sidebar_position:4,sidebar_label:"@lexical/selection"},sidebar:"docs",previous:{title:"@lexical/rich-text",permalink:"/lexical/docs/packages/lexical-rich-text"},next:{title:"@lexical/table",permalink:"/lexical/docs/packages/lexical-table"}},p={},c=[],s={toc:c};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("h1",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"h1"},"@lexical/selection")),(0,r.kt)("p",{parentName:"p"},"This package contains selection helpers for Lexical."),(0,r.kt)("h3",{parentName:"p"},"Methods"),(0,r.kt)("h4",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"h4"},"getStyleObjectFromCSS")),(0,r.kt)("p",{parentName:"p"},"Given a CSS string, returns an object from the style cache."),(0,r.kt)("pre",{parentName:"p"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function getStyleObjectFromCSS(css: string): {\n  [key: string]: string;\n} | null;\n")),(0,r.kt)("h4",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"h4"},"$patchStyleText")),(0,r.kt)("p",{parentName:"p"},"Applies the provided styles to the TextNodes in the provided Selection. Key names in the patch argument should be\nthe valid CSS properties (i.e., kebab-case)."),(0,r.kt)("pre",{parentName:"p"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function $patchStyleText(\n  selection: RangeSelection | GridSelection,\n  patch: {\n    [key: string]: string;\n  },\n): void;\n")),(0,r.kt)("h4",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"h4"},"$getSelectionStyleValueForProperty")),(0,r.kt)("p",{parentName:"p"},"Given a selection and a valid CSS property name, returns the current value of that property for TextNodes in the Selection, if set. If not set, it returns the defaultValue. If all TextNodes do not have the same value, it returns an empty string."),(0,r.kt)("pre",{parentName:"p"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function $getSelectionStyleValueForProperty(\n  selection: RangeSelection,\n  styleProperty: string,\n  defaultValue: string,\n): string;\n")),(0,r.kt)("h4",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"h4"},"$moveCaretSelection")),(0,r.kt)("p",{parentName:"p"},"Moves the selection according to the arguments."),(0,r.kt)("pre",{parentName:"p"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function $moveCaretSelection(\n  selection: RangeSelection,\n  isHoldingShift: boolean,\n  isBackward: boolean,\n  granularity: 'character' | 'word' | 'lineboundary',\n): void;\n")),(0,r.kt)("h4",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"h4"},"$isParentElementRTL")),(0,r.kt)("p",{parentName:"p"},"Returns true if the parent of the Selection anchor node is in Right-To-Left mode, false if not."),(0,r.kt)("pre",{parentName:"p"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function $isParentElementRTL(selection: RangeSelection): boolean;\n")),(0,r.kt)("h4",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"h4"},"$moveCharacter")),(0,r.kt)("p",{parentName:"p"},"Wraps $moveCaretSelection, using character granularity and accounting for RTL mode."),(0,r.kt)("pre",{parentName:"p"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function $moveCharacter(\n  selection: RangeSelection,\n  isHoldingShift: boolean,\n  isBackward: boolean,\n): void;\n")),(0,r.kt)("h4",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"h4"},"$selectAll")),(0,r.kt)("p",{parentName:"p"},"Expands the current Selection to cover all of the content in the editor."),(0,r.kt)("pre",{parentName:"p"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function $selectAll(selection: RangeSelection): void;\n")),(0,r.kt)("h4",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"h4"},"$setBlocksType")),(0,r.kt)("p",{parentName:"p"},"Converts all nodes in the selection that are of one block type to another specified by parameter"),(0,r.kt)("pre",{parentName:"p"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function $setBlocksType(\n  selection: RangeSelection,\n  createElement: () => ElementNode,\n): void;\n")),(0,r.kt)("h4",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"h4"},"$isAtNodeEnd")),(0,r.kt)("p",{parentName:"p"},"Returns true if the provided point offset is in the last possible position."),(0,r.kt)("pre",{parentName:"p"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function $isAtNodeEnd(point: Point): boolean;\n")),(0,r.kt)("h4",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"h4"},"$shouldOverrideDefaultCharacterSelection")),(0,r.kt)("p",{parentName:"p"},"Returns true if default character selection should be overridden, false if not. Used with DecoratorNodes"),(0,r.kt)("pre",{parentName:"p"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function $shouldOverrideDefaultCharacterSelection(\n  selection: RangeSelection,\n  isBackward: boolean,\n): boolean;\n"))))}m.isMDXComponent=!0}}]);